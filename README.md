# Orquestração com Kubernetes

## Sobre

Repositório pessoal de registro, referência e suporte para fins de aprendizado, consulta e acompanhamento da disciplina de Orquestração - Kubernets (Nível 5), da foramção DevOps, desenvolvido pela Rocketseat.

## Conteúdo Teórico

### Bloco A: Fundamentos de Kubernetes

O Bloco A introduz o Kubernetes como orquestrador de containers agnóstico a provedores, originado do projeto Borg do Google e mantido pela Cloud Native Computing Foundation (CNCF). O conteúdo explora sistematicamente os desafios fundamentais que motivaram a criação do Kubernetes, incluindo recuperação automática de falhas de containers, necessidade de replicação horizontal para distribuição de carga, elasticidade dinâmica para adaptação a variações de demanda, controle granular de recursos computacionais, e coordenação complexa de aplicações multi-container em ambientes distribuídos. Estes problemas, quando gerenciados manualmente, tornam-se rapidamente impraticáveis em escala, demandando soluções automatizadas e declarativas que o Kubernetes provê através de abstrações sofisticadas.

A arquitetura distribuída do Kubernetes, apresentada detalhadamente no bloco, fundamenta-se na separação entre plano de controle e nós de trabalho. O plano de controle, composto por componentes como kube-apiserver, etcd, kube-scheduler e kube-controller-manager, gerencia o estado do cluster e toma decisões de orquestração, enquanto os nós de trabalho executam kubelet, kube-proxy e a container runtime para gerenciar e executar as cargas de trabalho containerizadas. O documento explora as diversas opções de execução do Kubernetes, desde serviços gerenciados oferecidos por provedores de nuvem (EKS, GKE, AKS) até instalações auto-gerenciadas com ferramentas como kubeadm, além de ambientes locais para desenvolvimento usando kind, minikube ou k3s. A interação com clusters ocorre primariamente através do kubectl, complementado por ferramentas visuais como Lens e k9s, proporcionando interfaces alternativas para operações de gestão, deployment e troubleshooting.

>[!NOTE]
> [Kubernetes: Fundamentos de Orquestração de Containers](./.github/docs/content/bloco-a.md)
>
> [Apresentação de Slides](./.github/docs/content/presentations/bloco-a.pdf)

### Bloco B: Orquestrando Containers com Pods, ReplicaSets, Deployments e Services

O Bloco B apresenta uma exploração sistemática dos recursos fundamentais do Kubernetes utilizados para orquestrar containers em ambientes de produção, começando pela unidade atômica de deployment - o Pod - e evoluindo através de abstrações progressivamente mais sofisticadas. O conteúdo examina detalhadamente a natureza efêmera dos Pods, sua criação imperativa para experimentação rápida versus gestão declarativa através de manifestos YAML para ambientes produtivos, especificação de recursos computacionais, e mecanismos de acesso através de port-forwarding. A organização lógica de recursos através de namespaces é apresentada como fundação para governança multi-tenant, permitindo isolamento, aplicação de quotas de recursos e separação de ambientes dentro de clusters compartilhados.

A progressão conceitual avança para ReplicaSets como mecanismo de garantia de disponibilidade através de replicação automática, abordando suas capacidades de recuperação de falhas e limitações críticas para atualizações de versão que motivaram a criação de Deployments. Os Deployments são explorados como abstração de alto nível que orquestra ReplicaSets para implementar rolling updates sem downtime, rollbacks automatizados, gestão de histórico de versões e estratégias sofisticadas de atualização configuráveis através de parâmetros como maxSurge e maxUnavailable. O bloco culmina com Services como camada de rede que abstrai a localização dinâmica dos Pods efêmeros, fornecendo endpoints estáveis com descoberta automática via DNS e balanceamento de carga integrado, estabelecendo a separação fundamental entre gestão de ciclo de vida (Deployments) e exposição de rede (Services) que caracteriza arquiteturas bem projetadas no Kubernetes.

>[!NOTE]
> [Kubernetes: Orquestrando Containers com Pods, ReplicaSets, Deployments e Services](./.github/docs/content/bloco-b.md)

### Bloco C: Deployment e Configuração de Aplicações em Produção

O Bloco C explora o ciclo completo de implantação de aplicações reais no Kubernetes, utilizando uma aplicação NestJS como referência prática para demonstrar o processo desde containerização até gestão de configurações em ambientes de produção. O conteúdo aborda detalhadamente a construção de Dockerfiles otimizados utilizando técnicas de multi-stage builds para minimizar tamanho de images e maximizar eficiência de caching de layers, impactando diretamente velocidade de deployments e utilização de recursos. A gestão disciplinada de tags de container images emerge como prática crítica, contrastando problemas de tags mutáveis como `latest` que introduzem indeterminismo e impossibilidade de rollbacks precisos, com benefícios de tags imutáveis baseadas em semantic versioning ou commit hashes que garantem rastreabilidade exata e operações previsíveis. O processo de push de images para container registries e subsequente deployment através de manifestos YAML declarativos estabelece fundação para práticas sustentáveis de operação.

As estratégias de deployment no Kubernetes são exploradas em profundidade, desde rolling updates como estratégia padrão que substitui Pods gradualmente através de parâmetros configuráveis `maxSurge` e `maxUnavailable` permitindo zero-downtime deployments, até estratégia Recreate que causa indisponibilidade temporária mas garante que apenas uma versão execute por vez. Estratégias avançadas como blue-green e canary deployments são apresentadas como padrões implementáveis através de manipulação de labels e Services. A separação de configuração de código através de ConfigMaps para dados não-sensíveis e Secrets para informações confidenciais representa princípio fundamental de aplicações cloud-native, permitindo mesma image executar em múltiplos ambientes com configurações distintas. São detalhados diferentes métodos de injeção de configurações (variáveis individuais, importação completa via `envFrom`, ou montagem como volumes), melhores práticas de gestão de Secrets incluindo uso de base64 encoding, controle de acesso via RBAC, e integração com soluções externas como HashiCorp Vault ou Sealed Secrets para ambientes de produção que requerem criptografia, rotação automática e auditoria robusta.

>[!NOTE]
> [Kubernetes: Deployment e Configuração de Aplicações em Produção](./.github/docs/content/bloco-c.md)

### Bloco D - Conhecendo o HPA

O Bloco D apresenta uma análise técnica abrangente sobre estratégias de escalabilidade automática no Kubernetes, com foco especial no Horizontal Pod Autoscaler (HPA). O conteúdo explora inicialmente os fundamentos conceituais de escalabilidade em ambientes distribuídos, diferenciando as abordagens vertical e horizontal e destacando suas respectivas vantagens, limitações e casos de uso apropriados. A escala vertical, embora útil para aplicações legadas ou stateful complexas, enfrenta limitações físicas e de disponibilidade, enquanto a escala horizontal oferece redundância, tolerância a falhas e capacidade teoricamente ilimitada de expansão, tornando-se a abordagem preferencial para aplicações cloud-native modernas.

O documento detalha profundamente a arquitetura e funcionamento do Metrics Server, componente essencial que coleta métricas de recursos em tempo quase real, e as duas versões da API do HPA. A versão 1 (autoscaling/v1) oferece funcionalidade básica focada em CPU, enquanto a versão 2 (autoscaling/v2) introduz capacidades avançadas incluindo suporte a múltiplas métricas simultâneas, métricas customizadas e externas, controle granular sobre comportamento de escalamento através de políticas de scale-up e scale-down, e janelas de estabilização configuráveis. São apresentados exemplos práticos de implementação, técnicas de teste de carga utilizando ferramentas como FortIO e K6, estratégias de troubleshooting, e melhores práticas para ambientes de produção, proporcionando conhecimento completo desde conceitos fundamentais até otimizações avançadas para cenários complexos de escalabilidade em Kubernetes.

>[!NOTE]
> [Kubernetes: Horizontal Pod Autoscaler no Kubernetes](./.github/docs/content/bloco-d.md)

### Bloco E - Probes e Self Healing

O Bloco E explora os mecanismos fundamentais de probes e self-healing no Kubernetes, apresentando um sistema sofisticado de monitoramento e recuperação automática que transforma a plataforma em orquestrador inteligente capaz de detectar, diagnosticar e remediar problemas de saúde de aplicações sem intervenção manual. O conteúdo examina detalhadamente os três tipos de probes oferecidos pelo Kubernetes - Startup, Readiness e Liveness - cada um projetado para endereçar aspecto específico do ciclo de vida de containers. Startup Probes protegem containers com inicialização lenta de terminação prematura, permitindo tempo generoso para bootstrap enquanto mantêm responsividade para detecção de falhas reais. Readiness Probes controlam quando containers devem receber tráfego de produção, verificando não apenas se a aplicação iniciou, mas também se dependências externas críticas como bancos de dados, caches e APIs estão disponíveis e acessíveis.

Liveness Probes monitoram continuamente a saúde de containers durante toda sua vida útil, detectando estados irrecuperáveis como deadlocks, corrupção de memória ou consumo crítico de recursos que requerem reinicialização forçada para restaurar funcionalidade. O documento explora não apenas as mecânicas técnicas de implementação de cada tipo de probe através de verificações HTTP, TCP, exec commands ou gRPC, mas também práticas essenciais de configuração de parâmetros como initialDelaySeconds, periodSeconds, timeoutSeconds e failureThreshold que equilibram responsividade de detecção versus estabilidade operacional. Adicionalmente, são apresentados padrões complementares no nível de aplicação como Circuit Breakers para prevenir amplificação de falhas, Graceful Degradation para manter funcionalidade reduzida quando dependências falham, e Fault Injection para teste sistemático de resiliência, formando abordagem em camadas que combina capacidades de self-healing da plataforma com design consciente de aplicação para construir arquiteturas verdadeiramente resilientes e disponíveis.

>[!NOTE]
> [Kubernetes: Probes e Self Healing](./.github/docs/content/bloco-e.md)

### Bloco F - Entendendo Mais Sobre Volumes

O Bloco F explora o subsistema de armazenamento persistente do Kubernetes, apresentando sistema sofisticado de abstrações que permite aplicações stateful preservarem dados além do ciclo de vida efêmero de containers. O conteúdo examina detalhadamente a arquitetura em camadas composta por StorageClasses que abstraem características de diferentes backends de armazenamento, PersistentVolumes (PVs) que representam recursos físicos de armazenamento provisionados no cluster, e PersistentVolumeClaims (PVCs) que expressam requisições de armazenamento por usuários. A distinção fundamental entre volumes efêmeros (como emptyDir) apropriados para dados temporários e volumes persistentes essenciais para aplicações como bancos de dados estabelece base conceitual crítica. StorageClasses encapsulam provisioners específicos de fornecedores e parâmetros de configuração, permitindo administradores definirem classes de serviço que desenvolvedores podem consumir sem conhecimento de detalhes de implementação subjacentes.

O documento explora tanto provisionamento estático, onde administradores pré-criam PersistentVolumes que usuários posteriormente reivindicam, quanto provisionamento dinâmico que automaticamente cria volumes em resposta a PVCs quando nenhum PV existente satisfaz requisitos. São detalhados os diferentes modos de acesso (ReadWriteOnce, ReadOnlyMany, ReadWriteMany) que determinam como volumes podem ser compartilhados entre Pods e nós, políticas de recuperação (Retain, Delete) que controlam ciclo de vida de dados após deleção de claims, e integração com Deployments e StatefulSets para diferentes padrões de aplicação. Casos de uso práticos são apresentados incluindo bancos de dados relacionais, sistemas de upload de arquivos e logs compartilhados, complementados por melhores práticas como preferência por provisionamento dinâmico, escolha apropriada de access modes, uso de Retain para dados críticos, e implementação de estratégias de backup separadas, formando guia abrangente para gestão efetiva de armazenamento persistente em ambientes Kubernetes de produção.

>[!NOTE]
> [Kubernetes: Entendendo Volumes](./.github/docs/content/bloco-f.md)
